1: Minimal modification, only letter replacements, without replacing characters that would make the text indecipherable.
"Hello, World! How are you today?" -> "Hewwo, World! How awe you today?"
Path: Single replacement pass

2: Extensive modification of words, and insertion of extra characters and extension of existing vowels. Ignoring nonsensibility.
"Hello, World! How are you today?" -> "Hewwo, Wowwd!!! How awe youw twoday?"
Path: Replacement Pass -> Vowel and Punctuation Pass

3: Extreme modification of words beyond sensibility and adding on emoticons after punctuation.
"Hello, World! How are you today?" -> "Hewwooo, Wowwd!!! :3 How awe youw twodayyy? Nya~ >_<"
Path: Replacement Pass -> Randomized Vowel and Punctuation Extension pass -> Extra decorations and bits pass.

ALTERNATIVELY:

Pattern replacement pass: Replace single characters or patterns based on context. Using a lookahead system based on the largest pattern.
Word replacement pass: Split the string by whitespaces


Split String by whitespaces, iterate over each word, match words with replacements or continue, match for the largest patterns, going down the context list until no more matches remain.
1. Add char to buffer
2. If more than one pattern contains/matches buffer, add matching keys to list.
3. If keys list only has one key, replace matched pattern with the key's item.


--- Emotion ---
Alter the text based on a manually inputted, and/or automatically detected emotion.
EG Angry/Annoyed: "Shut up." -> "Shuddup!!! >M<" || Note: Combination of words would be difficult but funny
EG Excited: "Yay!" -> "YIPPEE!!! >W<" || "Shut up." -> "SHUDDUP!!! :D" || Note: Elements of randomness should be used to spice up the output.
EG Horny: "Forgive me father for I have sinned" -> "Fowgibe mwe daddy fow I habe sinned~" || Note: I can make this worse.

Two possible implementations of this:
1. A trait defining an Owoifier, defining functions for passes of each emotion type. Struct implementations would define each emotional conversion based on their intensity.
-> An owoifier works by chainging actions into a path, that may continue infinitely. It's slow, but allows for modularity.
2. An instantiable struct with several methods that can be chained to make an action path 